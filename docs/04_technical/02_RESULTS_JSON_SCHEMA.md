# 02 – results.json Schema

## 1. Role and purpose

`results.json` is the **sole source of truth** produced by the analysis engine.

**Key properties:**
- Contains all computed measurements from all executed analysis methods
- Serialized exactly once at the end of pipeline execution
- Never modified after creation (immutable)
- Independent of context files (contexts are for reporting only)
- Reproducible: same inputs → same results.json

**What it contains:**
- Execution metadata (file info, timestamp, config)
- Raw measurements from all analysis methods
- Scalar metrics suitable for contextualization
- Optional anomaly scores
- Exclusions: visualization_data (excluded by default to reduce file size)

**What it does NOT contain:**
- Interpretation or classification
- Threshold-based decisions
- Context-dependent annotations

---

## 2. Top-level structure

```json
{
  "timestamp": "<ISO 8601 datetime>",
  "metadata": { ... },
  "results": {
    "<category>": [
      { <AnalysisResult> },
      { <AnalysisResult> },
      ...
    ],
    ...
  }
}
```

### 2.1 Top-level fields

**`timestamp`** (string, ISO 8601)
- Datetime when the analysis started
- Format: `"2025-01-22T17:30:45.123456"`
- Generated by `ResultsAggregator.__init__()` via `datetime.now().isoformat()`

**`metadata`** (object)
- Execution metadata (see section 3)

**`results`** (object)
- Analysis results organized by category
- Keys: category names (`"temporal"`, `"spectral"`, etc.)
- Values: arrays of `AnalysisResult` objects (see section 4)

---

## 3. Metadata section

The `metadata` object contains execution context that is **not** analysis output but is necessary for interpretation.

### 3.1 Metadata fields

```json
"metadata": {
  "audio_file": "/absolute/path/to/file.flac",
  "audio_info": {
    "sample_rate": 48000,
    "channels": 2,
    "duration": 60.5,
    "frames": 2904000,
    "format": "FLAC",
    "subtype": "PCM_16"
  },
  "sample_rate": 48000,
  "channels": ["left", "right", "difference"],
  "preprocessing": {
    "normalize": {
      "enabled": true,
      "method": "rms",
      "target_level": -20.0
    },
    "segmentation": {
      "enabled": false
    }
  },
  "config_version": "1.0"
}
```

### 3.2 Field descriptions

**`audio_file`** (string)
- Absolute path to the analyzed audio file
- Set by `AnalysisRunner._load_audio()`

**`audio_info`** (object)
- Extracted via `AudioLoader.get_audio_info()` using `soundfile.info()`
- **`sample_rate`** (int): Native sample rate in Hz
- **`channels`** (int): Number of channels in original file (1 = mono, 2 = stereo)
- **`duration`** (float): Duration in seconds
- **`frames`** (int): Total number of samples
- **`format`** (string): Container format (e.g., "FLAC", "WAV")
- **`subtype`** (string): Encoding (e.g., "PCM_16", "PCM_24")

**`sample_rate`** (int)
- Sample rate used during analysis (same as `audio_info.sample_rate`)
- Redundant for convenience

**`channels`** (array of strings)
- Channels that were analyzed
- Possible values: `"left"`, `"right"`, `"mono"`, `"sum"`, `"difference"`
- Defined in protocol YAML: `channels.analyze`

**`preprocessing`** (object)
- Preprocessing configuration applied
- Mirrors the `preprocessing` section from protocol YAML
- **If no preprocessing:** `{}`
- **If normalization enabled:** includes `normalize` object
- **If segmentation enabled:** includes `segmentation` object

**`config_version`** (string)
- Protocol version string from protocol YAML
- Example: `"1.0"`

---

## 4. Results section

The `results` object contains all analysis outputs, organized by category.

### 4.1 Category structure

Each category is an **array** of `AnalysisResult` objects:

```json
"results": {
  "temporal": [
    { <AnalysisResult for envelope> },
    { <AnalysisResult for autocorrelation> },
    ...
  ],
  "spectral": [
    { <AnalysisResult for fft_global> },
    { <AnalysisResult for peak_detection> },
    ...
  ],
  "information": [
    { <AnalysisResult for mutual_information> }
  ],
  ...
}
```

**Category keys correspond to analysis families:**
- `"temporal"`
- `"spectral"`
- `"time_frequency"`
- `"modulation"`
- `"information"`
- `"inter_channel"`
- `"steganography"`
- `"meta_analysis"`

**If a category is disabled or has no methods, it is omitted entirely.**

---

## 5. AnalysisResult structure

Each analysis method produces an `AnalysisResult` object, defined in `audio_toolkit/engine/results.py`:

```python
@dataclass
class AnalysisResult:
    method: str
    measurements: Dict[str, Any]
    metrics: Optional[Dict[str, Any]] = None
    anomaly_score: Optional[float] = None
    visualization_data: Optional[Dict[str, Any]] = None
```

### 5.1 Field descriptions

**`method`** (string, required)
- Unique identifier for the analysis method
- Examples: `"envelope"`, `"fft_global"`, `"mutual_information"`
- Must match a registered method name in the registry

**`measurements`** (object, required)
- Raw measurements produced by the method
- Structure varies per method (see section 6)
- Can be nested: per-channel, per-segment, global
- Always present, even if empty (`{}`) in case of failure

**`metrics`** (object or null, optional)
- Scalar metrics suitable for contextual positioning
- Must contain only simple types: int, float, str, bool
- Used by reporting layer for range comparisons
- Examples: `{"window": "hann", "sample_rate": 48000}`
- **If not applicable:** `null`

**`anomaly_score`** (float or null, optional)
- Optional anomaly score between 0.0 and 1.0
- 0.0 = normal, 1.0 = highly anomalous
- Currently unused by most methods
- **If not computed:** `null`

**`visualization_data`** (object or null, optional)
- Data prepared for visualization (plot-ready arrays)
- **Excluded from JSON export by default** (to reduce file size)
- If `export_json(include_viz_data=True)`, this field is included
- Used internally during visualization generation
- **In exported results.json:** always `null`

### 5.2 Serialization behavior

When `ResultsAggregator.export_json()` is called:

1. All `AnalysisResult` objects are converted to dictionaries via `asdict()`
2. `visualization_data` fields are removed unless `include_viz_data=True`
3. Result is written to JSON with `indent=2` and `default=str` (converts non-serializable types)

---

## 6. Measurements structure patterns

The `measurements` field has flexible structure depending on the method's output.

**Note:** Example method names in this section (`fft_global`, `peak_detection`, `local_entropy`, `mutual_information`) are illustrative. Actual method availability and naming depends on the protocol and registered methods. See `A1_CATALOG_ANALYSES_OUTPUTS.md` for the complete current catalog.

### 6.1 Pattern 1: Per-channel measurements

**Most common pattern.** Each channel gets its own nested object.

**Example (from `fft_global`):**
```json
"measurements": {
  "left": {
    "n_fft": 2904000,
    "frequency_resolution": 0.0165289,
    "peak_frequency": 440.0,
    "peak_magnitude": 15234.5,
    "spectral_energy": 1.234e8
  },
  "right": {
    "n_fft": 2904000,
    "frequency_resolution": 0.0165289,
    "peak_frequency": 442.1,
    "peak_magnitude": 14987.3,
    "spectral_energy": 1.198e8
  },
  "difference": {
    "n_fft": 2904000,
    "frequency_resolution": 0.0165289,
    "peak_frequency": 78.5,
    "peak_magnitude": 523.7,
    "spectral_energy": 2.15e6
  }
}
```

**Structure:**
- Top-level keys: channel names (`"left"`, `"right"`, `"mono"`, `"sum"`, `"difference"`)
- Each channel contains a dict of scalar measurements

**Example (from `local_entropy`):**
```json
"measurements": {
  "left": {
    "mean_entropy": 7.234,
    "std_entropy": 0.456,
    "min_entropy": 6.12,
    "max_entropy": 8.45,
    "num_windows": 1234,
    "entropy_variation": 0.063
  },
  "right": {
    "mean_entropy": 7.189,
    "std_entropy": 0.432,
    "min_entropy": 6.08,
    "max_entropy": 8.52,
    "num_windows": 1234,
    "entropy_variation": 0.060
  }
}
```

### 6.2 Pattern 2: Global measurements

Methods that compute relationships across channels use a `"global"` key.

**Example (from `mutual_information`):**
```json
"measurements": {
  "global": {
    "num_channels": 3,
    "channel_names": ["left", "right", "difference"],
    "mi_pairs": {
      "left_vs_right": 0.234,
      "left_vs_difference": 0.056,
      "right_vs_difference": 0.048
    },
    "mean_mi": 0.113,
    "max_mi": 0.234,
    "samples_analyzed": 50000
  }
}
```

**Structure:**
- Single top-level key: `"global"`
- Contains all measurements for the method

### 6.3 Pattern 3: Mixed (per-channel + arrays)

Some methods store both scalar values and arrays/lists.

**Example (from `peak_detection`):**
```json
"measurements": {
  "left": {
    "num_peaks": 15,
    "peak_frequencies": [440.0, 880.0, 1320.0, 1760.0, ...],
    "peak_magnitudes": [15234.5, 8765.2, 4321.1, 2987.6, ...],
    "dominant_frequency": 440.0,
    "frequency_spread": 123.4
  },
  "right": {
    "num_peaks": 17,
    "peak_frequencies": [442.1, 884.2, 1326.3, ...],
    "peak_magnitudes": [14987.3, 8432.1, 4156.8, ...],
    "dominant_frequency": 442.1,
    "frequency_spread": 118.7
  }
}
```

**Notes:**
- Arrays are typically limited (e.g., first 20 peaks) to avoid bloat
- Full arrays go in `visualization_data`, not `measurements`

### 6.4 Pattern 4: Per-segment measurements (allowed but currently unused)

When segmentation is enabled in the protocol, methods **could** produce per-segment measurements. However, **no existing analysis currently emits this structure**. Most methods operate on full channels regardless of segmentation.

**Theoretical example:**
```json
"measurements": {
  "left": {
    "segment_0": {
      "energy": 0.45,
      "entropy": 7.2
    },
    "segment_1": {
      "energy": 0.67,
      "entropy": 7.8
    },
    "segment_2": {
      "energy": 0.34,
      "entropy": 6.9
    }
  }
}
```

**Status:**
- Schema supports this pattern
- No current method uses it
- Future methods may adopt this structure
- Consumers should handle both patterns (per-channel and per-segment)

---

## 7. Scalar metrics extraction

The reporting layer (`02_Generate_Report.py`) extracts **scalar metrics** from `measurements` for contextual positioning.

### 7.1 Extraction rules

**Goal:** Flatten nested measurements into `(scope, metric_name, value)` tuples.

**Algorithm (from `02_Generate_Report.py::_extract_scalar_metrics()`):**

1. Iterate over `measurements` keys (top-level)
2. For each key:
   - If value is a dict → treat key as scope, iterate nested dict
   - If value is scalar (int/float/str/bool) → treat top-level key as `"global"` scope
3. Collect only scalar values (skip lists, dicts, null)

**Example 1 (per-channel):**
```json
"measurements": {
  "left": {"mean": 0.5, "std": 0.1},
  "right": {"mean": 0.6, "std": 0.12}
}
```
**Extracts:**
- `("left", "mean", 0.5)`
- `("left", "std", 0.1)`
- `("right", "mean", 0.6)`
- `("right", "std", 0.12)`

**Example 2 (global):**
```json
"measurements": {
  "global": {
    "mean_mi": 0.234,
    "max_mi": 0.456
  }
}
```
**Extracts:**
- `("global", "mean_mi", 0.234)`
- `("global", "max_mi", 0.456)`

**Example 3 (mixed):**
```json
"measurements": {
  "num_peaks": 15,
  "dominant_frequency": 440.0
}
```
**Extracts:**
- `("global", "num_peaks", 15)`
- `("global", "dominant_frequency", 440.0)`

### 7.2 Non-scalar values

Arrays, nested dicts, and null values are **skipped** during scalar extraction.

**Example:**
```json
"measurements": {
  "left": {
    "mean": 0.5,
    "peak_frequencies": [440.0, 880.0, 1320.0],  // Skipped (array)
    "histogram": {"bins": [...], "counts": [...]}  // Skipped (nested dict)
  }
}
```
**Extracts only:**
- `("left", "mean", 0.5)`

---

## 8. Error handling and failures

When an analysis method fails, the error is **serialized as data**.

### 8.1 Error structure

**Implementation note:** The `AnalysisResult` dataclass does not formally include an `error` field. The runner may extend the result dict with error information before serialization, but this is **non-contractual**.

**Critical:** The `error` field is **not part of the guaranteed schema**. Its presence, structure, and content are subject to change.

**Consumers MUST NOT rely on the presence or structure of the `error` field.**

**Example (failure):**
```json
{
  "method": "failing_method",
  "measurements": {},
  "metrics": null,
  "anomaly_score": null,
  "error": "ValueError: Invalid parameter 'foo'"  // Non-contractual, may be absent
}
```

**Example (partial failure):**
```json
{
  "method": "method_with_error",
  "measurements": {
    "left": {"value": 0.5},
    "right": {}  // Failed for this channel
  },
  "metrics": null,
  "error": "Failed to process 'right' channel: division by zero"  // Non-contractual
}
```

### 8.2 Guarantees

**Guaranteed:**
- Failed methods are **not skipped**; they appear in results.json
- Empty measurements (`{}`) indicate failure
- Error messages are logged to console
- The pipeline continues executing other methods

**Not guaranteed:**
- Presence of `error` field
- Structure or format of `error` field
- Specific error message content

---

## 9. Visualization data (excluded by default)

### 9.1 Purpose

`visualization_data` contains plot-ready arrays that would bloat `results.json` if included.

**Examples of visualization_data:**

**From `autocorrelation`:**
```json
"visualization_data": {
  "left": {
    "lags": [0, 1, 2, 3, ..., 5000],
    "acf": [1.0, 0.987, 0.954, ..., 0.023]
  },
  "right": {
    "lags": [0, 1, 2, 3, ..., 5000],
    "acf": [1.0, 0.991, 0.962, ..., 0.019]
  }
}
```

**From `stft` (spectrogram):**
```json
"visualization_data": {
  "left": {
    "times": [0.0, 0.005, 0.010, ..., 60.5],
    "frequencies": [0, 10.7, 21.4, ..., 24000],
    "spectrogram": [[...], [...], ...]  // 2D array (time × freq)
  }
}
```

### 9.2 Exclusion behavior

**Default (`export_json(include_viz_data=False)`):**
- All `visualization_data` fields are set to `null` before export
- File size reduced by 10x–100x

**With visualization data (`export_json(include_viz_data=True)`):**
- Full arrays are included
- Used only for debugging or archival

**In practice:**
- Visualization is generated during analysis execution
- Plots are saved to `visualizations/` directory
- `results.json` remains compact

---

## 10. Complete example

**Note:** Method names and structures in these examples are illustrative and based on current implementation. Actual output depends on protocol configuration and registered methods.

### 10.1 Minimal example

```json
{
  "timestamp": "2025-01-22T17:30:45.123456",
  "metadata": {
    "audio_file": "/home/user/audio/test.flac",
    "audio_info": {
      "sample_rate": 48000,
      "channels": 2,
      "duration": 10.0,
      "frames": 480000,
      "format": "FLAC",
      "subtype": "PCM_16"
    },
    "sample_rate": 48000,
    "channels": ["left", "right"],
    "preprocessing": {
      "normalize": {
        "enabled": true,
        "method": "rms",
        "target_level": -20.0
      }
    },
    "config_version": "1.0"
  },
  "results": {
    "temporal": [
      {
        "method": "envelope",
        "measurements": {
          "left": {
            "envelope_mean": 0.123,
            "envelope_max": 0.987,
            "envelope_std": 0.045,
            "envelope_length": 240000
          },
          "right": {
            "envelope_mean": 0.118,
            "envelope_max": 0.954,
            "envelope_std": 0.042,
            "envelope_length": 240000
          }
        },
        "metrics": {
          "method": "hilbert"
        },
        "anomaly_score": null,
        "visualization_data": null
      }
    ],
    "spectral": [
      {
        "method": "fft_global",
        "measurements": {
          "left": {
            "n_fft": 480000,
            "frequency_resolution": 0.1,
            "peak_frequency": 440.0,
            "peak_magnitude": 12345.6,
            "spectral_energy": 1.234e8
          },
          "right": {
            "n_fft": 480000,
            "frequency_resolution": 0.1,
            "peak_frequency": 442.1,
            "peak_magnitude": 12098.4,
            "spectral_energy": 1.198e8
          }
        },
        "metrics": {
          "window": "hann",
          "sample_rate": 48000
        },
        "anomaly_score": null,
        "visualization_data": null
      }
    ]
  }
}
```

### 10.2 Example with global measurements

```json
{
  "timestamp": "2025-01-22T18:15:30.987654",
  "metadata": {
    "audio_file": "/data/signal.flac",
    "audio_info": { ... },
    "sample_rate": 48000,
    "channels": ["left", "right", "difference"],
    "preprocessing": {},
    "config_version": "1.0"
  },
  "results": {
    "information": [
      {
        "method": "mutual_information",
        "measurements": {
          "global": {
            "num_channels": 3,
            "channel_names": ["left", "right", "difference"],
            "mi_pairs": {
              "left_vs_right": 0.234,
              "left_vs_difference": 0.056,
              "right_vs_difference": 0.048
            },
            "mean_mi": 0.113,
            "max_mi": 0.234,
            "samples_analyzed": 50000
          }
        },
        "metrics": {
          "num_bins": 64
        },
        "anomaly_score": null,
        "visualization_data": null
      }
    ]
  }
}
```

---

## 11. Schema evolution and stability

### 11.1 Stability guarantees

**Stable (do not change):**
- Top-level keys: `timestamp`, `metadata`, `results`
- Metadata keys: `audio_file`, `sample_rate`, `channels`
- AnalysisResult keys: `method`, `measurements`

**Additive changes allowed:**
- New metadata fields (backwards-compatible)
- New AnalysisResult fields (e.g., `confidence`, `provenance`)
- New categories in `results`

**Breaking changes to avoid:**
- Renaming existing scalar metric names (breaks context files)
- Changing measurement structure for existing methods (breaks parsers)
- Removing required fields

### 11.2 Versioning

- `metadata.config_version`: Protocol version (user-defined)
- **No explicit results.json format version** (assumes forward compatibility)
- If incompatible changes are needed, consider adding `"schema_version": "2.0"` at top level

---

## 12. File size considerations

### 12.1 Typical sizes

**With visualization_data excluded (default):**
- Minimal protocol (5 methods): ~10–50 KB
- Baseline protocol (20 methods): ~100–500 KB
- Full protocol (30 methods): ~500 KB – 2 MB

**With visualization_data included:**
- Can reach 10–100 MB (due to spectrograms, autocorrelation arrays)

### 12.2 Size optimization strategies

**In measurements:**
- Limit array lengths (e.g., first 20 peaks, not all 1000)
- Use float precision judiciously (6 significant figures via `format_value()`)

**In visualization_data:**
- Downsample large arrays before storing
- Use `max_samples` limits in analysis methods

**Export:**
- Default: `include_viz_data=False`
- Use `gzip` compression for archival storage

---

## 13. Relationship to other files

### 13.1 `config_used.json`

- Optionally written alongside `results.json`
- Contains the full protocol YAML as JSON
- Allows exact reproduction of analysis

**Connection:**
- `metadata.config_version` references the protocol version
- `config_used.json` is the full source

### 13.2 Context files (reporting layer)

- Context files (`context_<family>.yaml`) define reference ranges
- **Contexts are never read by the analysis engine**
- Reporting layer (`02_Generate_Report.py`) compares measurements against contexts
- Measurements in `results.json` are independent of contexts

---

## 14. Usage by consumers

### 14.1 Parsing results.json

**Recommended approach:**

```python
import json
from pathlib import Path

# Load
with open("results.json") as f:
    results = json.load(f)

# Access metadata
sample_rate = results["metadata"]["sample_rate"]
channels = results["metadata"]["channels"]

# Iterate methods
for category, methods in results["results"].items():
    for method_result in methods:
        method_name = method_result["method"]
        measurements = method_result["measurements"]
        
        # Check for empty measurements (indicates failure)
        if not measurements:
            print(f"Method {method_name} failed (empty measurements)")
            # Note: 'error' field may or may not be present (non-contractual)
            continue
        
        # Extract scalar metrics
        for channel, metrics in measurements.items():
            if isinstance(metrics, dict):
                for metric_name, value in metrics.items():
                    if isinstance(value, (int, float)):
                        print(f"{method_name}/{channel}/{metric_name}: {value}")
```

**Error handling:**
- Always check if `measurements` is empty before processing
- Do NOT rely on the `error` field (non-contractual)
- Failed methods will have `measurements: {}`

### 14.2 Common queries

**Get all peak frequencies across channels:**
```python
for result in results["results"]["spectral"]:
    if result["method"] == "peak_detection":
        for channel, data in result["measurements"].items():
            print(f"{channel}: {data['peak_frequencies']}")
```

**Check if normalization was applied:**
```python
preprocessing = results["metadata"]["preprocessing"]
normalized = preprocessing.get("normalize", {}).get("enabled", False)
```

---

## 15. JSON serialization details

### 15.1 Serialization process

**Implemented in:** `ResultsAggregator.export_json()`

**Steps:**
1. Call `get_results()` to build result dict
2. If `include_viz_data=False`: remove all `visualization_data` keys
3. Write to file with `json.dump(results, f, indent=2, default=str)`

**`default=str` behavior:**
- Converts non-serializable types (e.g., `numpy.float64`) to strings
- Ensures NumPy types are handled gracefully
- Datetime objects → ISO strings

### 15.2 Numeric precision

**From 02_Generate_Report.py:**
```python
def format_value(v: Any) -> str:
    if isinstance(v, float):
        if v != v:  # NaN
            return "NaN"
        if v == float("inf"):
            return "inf"
        if v == float("-inf"):
            return "-inf"
        return f"{v:.6g}"  # 6 significant figures
    return str(v)
```

**In results.json:**
- Python `float` values are serialized with full precision
- Reporting layer formats for human readability

---

## 16. Document status

This document was generated on **2025-01-22** after comprehensive review of:

- `audio_toolkit/engine/results.py` (122 lines)
- `audio_toolkit/engine/runner.py` (679 lines)
- `02_Generate_Report.py` (852 lines)
- Multiple analysis modules (`temporal.py`, `spectral.py`, `information.py`, etc.)
- Example protocol files

**Comprehensiveness:**
- Structure, fields, patterns, serialization, error handling, examples, usage

**Accuracy:**
- All field names, types, and behaviors verified against source code

This document is **technically exhaustive** with respect to the `results.json` schema and serialization process as of 2025-01-22.